## 💡 바쁜 사람들을 위해 결론부터! 

1. BigO 표기법은 알고리즘의 시간 복잡도나 공간 복잡도를 표현하는 방법 중 하나이다. 
2. “이 코드가 얼마나 효율적인가?” 라는 결론을 내리고 판단하는 데에 사용하는 방법론이다.
3. 앞으로 개발자를 희망하고, 코드를 잘 짜기 위해선, 알아둬서 나쁠 건 없다!

## 🅾️ Big O 표기법이란?

알고리즘의 시간 복잡도나 공간 복잡도를 표현하는 방법이다. 이는 입력 크기가 증가할 때 알고리즘의 성능이 어떻게 변화하는지를 나타낸다. 즉, 어떤 함수의 입력 값이 늘어나는 것과 함수의 실행 시간이 변하는 관계를 의미합니다. 입력의 크기와 실행시간의 관계를 말합니다. **최악의 경우 시나리오를 기준**으로 한다. 어렵게 생각할 것 없다. 아래의 비유를 통해 쉽게 이해할 수 있다. 

## 문제 해결의 두 가지 접근 방식

우리가 `1부터 100까지의 모든 수를 더하는 문제`를 생각해 보자. 이 문제를 해결하는 방법은 여러 가지가 있지만, 오늘은 유명한 문제를 두 가지 주요 접근 방식을 통해 풀어보며 이해를 해볼 것이다.

## 접근 방식 1: 순차적 덧셈

첫 번째 방법은 각 숫자를 순차적으로 더하는 것이다. 즉, 다음과 같은 방식으로 진행된다.

```markdown
1 + 2 + 3 + 4 + ... + 100
```

이 방법은 직관적이고 간단하다. 하지만 이 경우, 우리가 더해야 할 숫자의 개수가 많아질수록 계산 시간이 선형적으로 증가한다. 세상에 이런 사람밖에 없다면, n 개의 숫자를 순차적으로 더해보세요! 라는 질문에서, 모두가 1부터 n 까지의 덧셈을 반복하고 있다면, 해당 문제의 시간 복잡도는 `O(n)`이 된다.

## 접근 방식 2: 수학적 공식을 활용한 덧셈

두 번째 방법은 수학적 공식을 사용하는 것이다. 그러나 1부터 n까지의 합을 구하는 공식은 다음과 같다:

```markdown
S= n(n+1) / 2 
```

여기서 n은 마지막 숫자일 때, 다음과 같은 공식으로 빠르고 쉽게 풀 수 있다. 따라서, n=100일 때, 해당 공식을 통해서 

```markdown
S=100(100+1) / 2 =5050
```

이 방법은 `딱 한 번의 계산`으로 결과를 도출할 수 있기 때문에, 시간 복잡도는 상수 시간 `O(1)`이다. 학창시절 수학시간에 꼭 나오는 질문중 하나인, **“선생님 왜 수학을 배워야해요?”** 라는 질문과, 서술형에서 답만 맞춘 친구가 하는 투정인 **“답만 맞추면 되는 거 아녜요?!”** 라는 질문에는 앞선 예시를 들며 답을 할 수 있게 되는 것이다. ~~“둘 다 내가 한 말이란 건 비밀”~~  따라서 코딩 테스트를 보는 과정에서 이러한 사고 능력이 실무에 쓰이진 않더라도, 이러한 역량이 있는지 간접적으로 파악할 수는 있기에 보는 것이라고 생각한다.

## ✅ 잘짠 코드란?

1. 매우 빠르게 작동하는 코드인가?
2. 메모리 사용량이 적은 코드인가?
3. 읽기 쉬운 코드인가?

## 빠르게 작동하는지는 어떻게 알까?

컴퓨터 앞에 서서 타이머를 잡고서 시~~~작! 하는 방법도 물론 방법중 하나이다. 그러나, 매 순간 타이머를 붙들고 앞에 서있기는 힘들다. 따라서, performance.now() 함수를 이용해서 내장된 함수를 이용해 시간을 측정할 수 있다.

```tsx
function addUpTo(n) {
	let total = 0;
	for (let i = 1; i <= n; i++) {
		total += i;
	}
	return total;

let ti = performance.now() ;
addUpTo ( 1000000000) ;
let t2 = performance.now () ;
console.1og(`Time Elapsed: ${(t2 - t1) / 1000`} seconds.
```

두 코드의 속도를 봤을때 얼마나 더 좋은지 비교 할 수 있을까? 그냥 이 두 시간은 빼주는 것으로 충분한가? 우리는 모두 다른 기기를 쓰고 있고, 같은 기기라도 노후화에 따라서도 다른 성능을 낸다. 따라서, **연산의 수를 통해서 표기를 하자 라는 결론이 나오게 되었고 그것이 BigO 표기법이라고 보면 된다.**

해당 함수에는 몇 가지 연산이 있을까?  total += i 를 n 번 반복하니 n 번일까? 그렇지만은 않다.

1.  total을 0으로 지정할 때
2. 최초의 i 를 1로 지정할 때
3. 그렇게 i 가 n 보다 작거나 같은지 비교할 때
4. i 를 n 이 될때까지 1씩 더할 때
5. 그렇게 total 에 i 를 더할 때

이 모든 순간이 연산이다. 그러나, 해당 연산들 중 가장 영향령이 큰 함수는 바로 total += i 를 n 번 하는 것이다. 

## ✨ 시간 복잡도는 알겠는데 공간 복잡도는?

눈치가 빠른 분들은 눈치챘겠지만, 메모리 사용량이 적은 코드가 바로 공간 복잡도를 고려한 코드이다. 정해져있는 시간, 공간상의 제약 상에서 좋은 코드를 짜는 것이 좋은 코드라는 것이다. 우리에게 중요한 것은 알고리즘 자체 이다. 만약 n이 커지는 것이 빅오에서는 바로 그것을 보려고 하는 것이잖아요. 그렇기 때문에 n이 커질수록 입력이 커진다는 것을 가정한다. 이 때 중요한 점은 입력이 차지하는 공간은 관심 없고. 알고리즘 자체가 어떤 영향을 주는지에만 관심이 있다는 것이다.

우선 boolean, number, undefined, null은 자바스크립트에서 모두 불변 공간입니다. 그렇게 때문에 입력의 크기와는 상관 없이, 숫자가 1이든 1000이든 모두 불변 공간이라고 여긴다. 즉, boolean이 true이든 false이든 똑같은 공간을 차지 한다. string은 조금 다르다. string O(n) 공간이 필요합니다.

만약 n이 문자열의 길이라면, 1000자인 입력이 있다면, 좋지 않은 예이다. 만약 50자라면 그 문자열은 길이가 1자인 문자열보다 50배 더 많은 공간을 차지하게 되는 것이다. reference 타입, 배열과 객체도 같습니다. 대부분 O(n)이다.


```tsx

function sum(arr) {
	let total = 0;
	for(let i = 0 ; i< arr.length; i++) {
		total += arr[i];
		}
	return total;
}
```

 다음의 식은 공간 복잡도가 어떨까? arr.length에 따라서 바뀌니까 O(n) 일까? 그렇지 않다. arr 의 길이와는 상관없이 arr.length의 가변값에 따라서, 연산의 횟수 즉, 정해지는 건 시간일 뿐이다. 우리는 그 연산 결과, total 이란 값 속에 어떤 값이 들어가는가? 에 대해서 집중해야만 한다. 최초에 0 을 배정받았듯이 n을 배정받으면 되기에 그냥 하나의 숫자가 total 속으로 들어간다고 생각하면 된다. 즉 O(1)이다.

```tsx
function double (arr) {
	let newArr = [];
	for (let i = 0; i < arr.length; i++) {
		newArr.push(2 * arri]);
	}
	return newArr;
}
```

다음과 같은 경우엔 arr의 크기에 따라서,  newArr의 배열 크기가 정해진다. 즉 그 배열 자체의 길이가 점차 늘어나게 되는 것이기 떄문에, 해당 함수의 공간 복잡도는 O(n)이다. 

## Big O 표기법의 중요성

이 두 가지 접근 방식을 통해 우리는 문제 해결 과정에서 **시간 복잡도**의 개념을 이해할 수 있었다. 첫 번째 방법은 입력 크기에 따라 더해야 하는 시간이 선형적으로 증가하는 반면, 두 번째 방법은 입력 크기와 관계없이 일정한 시간을 소요한다. 그러나, 이는 **공간 복잡도** 라는 개념에서도 사용한다. 

**개발을 하다보면 앞선 예시보다 훨씬 더 복잡한 상황**에 마주하게 된다. 그리고 그 상황 속에서 이러한 능력은 필수 불가결하다. **이처럼 동일한 문제라도 접근 방식에 따라 효율성이 크게 달라질 수 있다.** Big O 표기법은 알고리즘의 성능을 평가하고 최적화하는 데 중요한 도구이다. 따라서 문제를 해결할 때는 단순히 정답을 찾는 것뿐만 아니라, 그 과정에서의 효율성도 고려해야 한다.

이러한 비유를 통해 우리는 다양한 문제 해결 전략을 탐구하고, 각 전략의 장단점을 이해할 수 있는 기회를 가질 수 있다. 더 좋은 코드를 짜기 위해서 기본적인 방법론이니 알아둬서 나쁠 건 없다! 이미 익숙해진 분들이 이런 질문을 듣는다면, “+란 기호가 뭐예요 ?” 라는 질문에 답하는 것과도 같다.
